//! Game input handler for simulation interactions

use super::context::Rect;
use super::events::{InputEvent, MouseButton, ViewportId};
use super::handler::InputHandler;
use super::state::InputState;

/// Actions generated by game input
#[derive(Debug, Clone)]
pub enum GameAction {
    /// Click in a viewport at the given viewport-local coordinates
    ViewportClick {
        viewport: ViewportId,
        /// Position relative to viewport (0,0 = top-left of viewport)
        local_pos: [f32; 2],
        button: MouseButton,
    },
}

/// Input handler for game/simulation interactions
///
/// This handler captures clicks in game viewports and converts them to
/// viewport-local coordinates. The App can then retrieve these actions
/// and apply them to the appropriate simulation.
pub struct GameInputHandler {
    /// The viewport ID for the main game view
    game_viewport_id: ViewportId,
    /// Actions generated this frame
    actions: Vec<GameAction>,
    /// Last known viewport rect (for coordinate conversion)
    viewport_rect: Option<Rect>,
}

impl GameInputHandler {
    /// Creates a new game input handler
    ///
    /// # Arguments
    /// * `game_viewport_id` - The viewport ID to listen for (typically ViewportId(0))
    pub fn new(game_viewport_id: ViewportId) -> Self {
        Self {
            game_viewport_id,
            actions: Vec::new(),
            viewport_rect: None,
        }
    }

    /// Update the viewport rectangle
    ///
    /// Should be called after layout to ensure coordinate conversion is accurate.
    pub fn set_viewport_rect(&mut self, rect: Rect) {
        self.viewport_rect = Some(rect);
    }

    /// Take all actions generated this frame
    ///
    /// This consumes the actions, leaving the handler empty for the next frame.
    pub fn take_actions(&mut self) -> Vec<GameAction> {
        std::mem::take(&mut self.actions)
    }

    /// Get reference to actions without consuming them
    pub fn actions(&self) -> &[GameAction] {
        &self.actions
    }

    /// Convert screen position to viewport-local position
    fn screen_to_local(&self, screen_pos: [f32; 2]) -> Option<[f32; 2]> {
        let rect = self.viewport_rect?;
        Some([screen_pos[0] - rect.x, screen_pos[1] - rect.y])
    }
}

impl InputHandler for GameInputHandler {
    fn name(&self) -> &str {
        "game"
    }

    fn priority(&self) -> u32 {
        // Medium priority - after UI (100+), before global (0-49)
        75
    }

    fn handle_event(&mut self, event: &InputEvent, _state: &InputState) -> bool {
        match event {
            InputEvent::Click {
                viewport: Some(viewport_id),
                pos,
                button,
            } if *viewport_id == self.game_viewport_id => {
                if let Some(local_pos) = self.screen_to_local(*pos) {
                    self.actions.push(GameAction::ViewportClick {
                        viewport: *viewport_id,
                        local_pos,
                        button: *button,
                    });
                    return true;
                }
                false
            }

            InputEvent::Click { viewport: None, .. } => {
                tracing::warn!("Click event missing viewport - input system bug");
                false
            }

            // Could handle other event types here (drag, hover, etc.)
            _ => false, // Don't consume events we don't care about
        }
    }

    fn begin_frame(&mut self) {
        // Clear actions from previous frame
        self.actions.clear();
    }

    fn update(&mut self, _state: &InputState) {
        // Could track continuous state here if needed (e.g., hover)
    }

    fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }
}
